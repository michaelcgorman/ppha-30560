<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <style>
        .chart-container {
            max-width: 1050px;
            margin: 0 auto;
            /* auto centers the div */
            font-family: 'Franklin Gothic Medium', 'Arial Narrow', Arial, sans-serif;
        }

        svg {
            overflow: visible;
        }

        h1 {
            text-align: center;
        }

        .pop-up {
            position: absolute; 
            border: 1px solid black;
            border-radius: 1px;
            line-height: 1.2;
            width: 200px;
            pointer-events: none;
            background-color: white;
            padding: 10px;
            opacity: 0;
        }

     
    </style>
</head>

<body>
    <div class="chart-container">
        <h1 class="headline">
            Commute Times
        </h1>

        <svg width="975px" height="610px"></svg>

        <div class="pop-up"></div>
    </div>
</body>

<!-- add your script blocks at the end -->
<script src="https://d3js.org/d3.v6.min.js"></script>
<!-- we're using d3 version 6 (the latest version) for all out work -->

<script src="https://unpkg.com/topojson@3"></script>

<!-- The following script is copied from https://observablehq.com/@d3/color-legend -->
<script>
    function legend({
  color,
  title,
  tickSize = 6,
  width = 320, 
  height = 44 + tickSize,
  marginTop = 18,
  marginRight = 0,
  marginBottom = 16 + tickSize,
  marginLeft = 0,
  ticks = width / 64,
  tickFormat,
  tickValues
} = {}) {

  const svg = d3.create("svg")
      .attr("width", width)
      .attr("height", height)
      .attr("viewBox", [0, 0, width, height])
      .style("overflow", "visible")
      .style("display", "block");

  let tickAdjust = g => g.selectAll(".tick line").attr("y1", marginTop + marginBottom - height);
  let x;

  // Continuous
  if (color.interpolate) {
    const n = Math.min(color.domain().length, color.range().length);

    x = color.copy().rangeRound(d3.quantize(d3.interpolate(marginLeft, width - marginRight), n));

    svg.append("image")
        .attr("x", marginLeft)
        .attr("y", marginTop)
        .attr("width", width - marginLeft - marginRight)
        .attr("height", height - marginTop - marginBottom)
        .attr("preserveAspectRatio", "none")
        .attr("xlink:href", ramp(color.copy().domain(d3.quantize(d3.interpolate(0, 1), n))).toDataURL());
  }

  // Sequential
  else if (color.interpolator) {
    x = Object.assign(color.copy()
        .interpolator(d3.interpolateRound(marginLeft, width - marginRight)),
        {range() { return [marginLeft, width - marginRight]; }});

    svg.append("image")
        .attr("x", marginLeft)
        .attr("y", marginTop)
        .attr("width", width - marginLeft - marginRight)
        .attr("height", height - marginTop - marginBottom)
        .attr("preserveAspectRatio", "none")
        .attr("xlink:href", ramp(color.interpolator()).toDataURL());

    // scaleSequentialQuantile doesnâ€™t implement ticks or tickFormat.
    if (!x.ticks) {
      if (tickValues === undefined) {
        const n = Math.round(ticks + 1);
        tickValues = d3.range(n).map(i => d3.quantile(color.domain(), i / (n - 1)));
      }
      if (typeof tickFormat !== "function") {
        tickFormat = d3.format(tickFormat === undefined ? ",f" : tickFormat);
      }
    }
  }

  // Threshold
  else if (color.invertExtent) {
    const thresholds
        = color.thresholds ? color.thresholds() // scaleQuantize
        : color.quantiles ? color.quantiles() // scaleQuantile
        : color.domain(); // scaleThreshold

    const thresholdFormat
        = tickFormat === undefined ? d => d
        : typeof tickFormat === "string" ? d3.format(tickFormat)
        : tickFormat;

    x = d3.scaleLinear()
        .domain([-1, color.range().length - 1])
        .rangeRound([marginLeft, width - marginRight]);

    svg.append("g")
      .selectAll("rect")
      .data(color.range())
      .join("rect")
        .attr("x", (d, i) => x(i - 1))
        .attr("y", marginTop)
        .attr("width", (d, i) => x(i) - x(i - 1))
        .attr("height", height - marginTop - marginBottom)
        .attr("fill", d => d);

    tickValues = d3.range(thresholds.length);
    tickFormat = i => thresholdFormat(thresholds[i], i);
  }

  // Ordinal
  else {
    x = d3.scaleBand()
        .domain(color.domain())
        .rangeRound([marginLeft, width - marginRight]);

    svg.append("g")
      .selectAll("rect")
      .data(color.domain())
      .join("rect")
        .attr("x", x)
        .attr("y", marginTop)
        .attr("width", Math.max(0, x.bandwidth() - 1))
        .attr("height", height - marginTop - marginBottom)
        .attr("fill", color);

    tickAdjust = () => {};
  }

  svg.append("g")
      .attr("transform", `translate(0,${height - marginBottom})`)
      .call(d3.axisBottom(x)
        .ticks(ticks, typeof tickFormat === "string" ? tickFormat : undefined)
        .tickFormat(typeof tickFormat === "function" ? tickFormat : undefined)
        .tickSize(tickSize)
        .tickValues(tickValues))
      .call(tickAdjust)
      .call(g => g.select(".domain").remove())
      .call(g => g.append("text")
        .attr("x", marginLeft)
        .attr("y", marginTop + marginBottom - height - 6)
        .attr("fill", "currentColor")
        .attr("text-anchor", "start")
        .attr("font-weight", "bold")
        .attr("class", "title")
        .text(title));

  return svg.node();
}
</script>

<script>
    console.log({d3})
    console.log({topojson})
    let width = 975;
    let height = 610;

    let sel_cols = [
            "under 10 minutes",
            "10 to 20 minutes",
            "20 to 30 minutes",
            "30 to 40 minutes",
            "over 40 minutes"
    ]
            
    let sel_colors = [
        "#fef0d9", // "under 10 minutes",
        "#fdcc8a", // "10 to 20 minutes",
        "#fc8d59", // "20 to 30 minutes",
        "#e34a33", // "30 to 40 minutes",
        "#b30000"  // "over 40 minutes",
    ]

    let svg = d3.select("body").select("svg")

    d3.json("topo_data.json").then(function (data) {
        console.log({data})

        let counties = topojson.feature(data, data.objects.county_commute_times)
        let states = topojson.feature(data, data.objects.state_borders)

        console.log({counties})
        console.log({states})

        let projection = d3.geoIdentity()
            .fitSize([width, height], counties)
            .reflectY(true)

        let path = d3.geoPath(projection)

        let color = d3.scaleOrdinal()
            .domain(sel_cols)
            .range(sel_colors)

        svg.append("g")
            .attr("class", "counties")
            .selectAll("path")
            .data(counties.features.filter(d => d.geometry != null))
            .join("path")
            .attr("d", path)
            .attr("fill", d => color(d.properties.median_length))            

        svg.append("path")
            .datum(topojson.mesh(data, data.objects.state_borders, function(a, b) { return a !== b }))
            .attr("class", "state_borders")
            .attr("d", path)
            .attr("fill", "none")
            .attr("stroke", "#fff")

        svg.append("g")
            .attr("class", "color_legend")
            .attr("transform", "translate(650, 0)")
            .append(() => legend({
                color: d3.scaleThreshold([10, 20, 30, 40], sel_colors),
                title: "Median Commute (minutes)",
                width: 240
            }))

        svg.selectAll(".color_legend svg g rect")
            .attr("stroke", "#ccc")
            .attr("stroke-width", "0.5px")

        let county_paths = d3.selectAll(".counties path")
        let popup = d3.select(".pop-up")

        county_paths.on("mouseover", (event, d) => {
            d3.select(event.srcElement)
                .attr("stroke", "#666")
                .attr("stroke-width", "1px")

            popup
                .style("opacity", 1)
                .style("left", (event.x + 10) + "px")
                .style("top", (event.y - 15) + "px")
                .html("<b>" + d.properties.NAME + "</b><br />Median commute: " + d.properties.median_length)
        })

        county_paths.on("mouseout", (event, d) => {
            d3.select(event.srcElement)
                .attr("stroke", "none")
                .attr("stroke-width", "0px")

            popup
                .style("opacity", 0)
        })

    })

</script>